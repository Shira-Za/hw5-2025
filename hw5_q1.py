import pathlib
import pandas as pd
import numpy as np
from typing import Union, Tuple
import matplotlib.pyplot as plt

class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        """
        Initialize a new QuestionnaireAnalysis instance.

        Parameters
        ----------
        data_fname : Path/str
            file name (string) or file path

        """
        if not isinstance(data_fname, (str, pathlib.Path)):
            raise TypeError("data_fname must be a string or Path.")
        
        self.data_fname = pathlib.Path(data_fname)

        if not self.data_fname.exists():
            raise ValueError(f"File does not exist: {self.data_fname}")


    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
        with open(self.data_fname, 'r') as file:
            self.data = pd.read_json(file)
        return self.data
    
    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.

        Returns
        -------
        hist : np.ndarray
            Number of people in a given bin
        bins : np.ndarray
            Bin edges
        """
        bin_edges = np.arange(0, 110, 10)
        ages = self.data['age'].dropna()

        hist, bins = np.histogram(ages, bins=bin_edges)

        # Plot the histogram
        plt.figure()
        plt.hist(ages, bins=bins, edgecolor='black', align='left')
        plt.xticks(bins)
        plt.xlabel("Ages")
        plt.ylabel("# of Participants")
        plt.title("Age Distribution")
        plt.tight_layout()

        return hist, bins

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

        Returns
        -------
        df : pd.DataFrame
            A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
            the (ordinal) index after a reset.
        """
        bool_mask = self.data['email'].apply(
            lambda email: isinstance(email, str)
            and email.count('@') == 1 #contains only 1 @
            and not (email.startswith(('@', '.')) or email.endswith(('@', '.'))) #doesn't start or end with @/.
            and '.' in email #contains a dot
            and email.find('@') < (len(email) - 1) #not the last char
            and email[email.find('@') + 1] != '.' #there is no . after @
            and len(email) < 320 #maximal length of an email address
            and ' ' not in email #doesn't include spaces
        )
        df = self.data[bool_mask].reset_index(drop=True)

        return df

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

        Returns
        -------
        df : pd.DataFrame
            The corrected DataFrame after insertion of the mean grade
        arr : np.ndarray
            Row indices of the students that their new grades were generated
        """
        df = self.data.copy()
        cols = ['q1', 'q2', 'q3', 'q4', 'q5']
        subset = df[cols]
        mask = subset.isna().any(axis=1)
        na_idx = df.index[mask].to_numpy()
        for i in na_idx:
            row = df.loc[i, cols]
            row_mean = row.mean(skipna=True)
            df.loc[i, cols] = row.fillna(row_mean)
        
        return df, na_idx

  
